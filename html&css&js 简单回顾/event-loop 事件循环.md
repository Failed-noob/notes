### event-loop 事件循环 



先要了解**js的运行机制;**

1.所有的同步任务都在主线程上执行 形成一个执行栈;



2.主线程之外  ,还存在一个 任务队列 只要异步任务 有了 运行结果 就会在任务队列中 放置一个事件;



3.当执行栈的中的所有同步任务全部执行完毕 系统就会读取任务列表 看看 任务队列中有哪些事件.那些对应的异步任务 结束等待状态 进入执行栈 开始执行



[

​	一个浏览器环境只能有一个事件循环，而一个事件循环可以多个任务队列，每个任务都有一个任务源（task  source）;但是，同一个任务队列中的任务必须按照先进先出的顺序执行。多个人物队列是为了方便控制优先级。任务队列是一个先进先出的队列。



**异步的运行机制**就是：

　　（1）所有同步任务都在主线上执行，形成一个执行栈；

　　（2）主线程之外还存在一个任务队列，只要异步任务有了运行结果，就在任务队列之中存放一个事件；

　　（3）一旦执行栈中的所有同步任务执行完成，系统就会读取任务队列，看看里边有哪些事件；那些对应的异步任务，就结束等待，进入执行栈，开始执行。

　　（4）主线程不断的重复执行第三步，直至任务队列没有任务

]



这整个流程就称为事件循环;



然而 **异步任务 又分为 微任务 和 宏任务**

常见的宏任务 script (整体代码) setTimeout setInterval setImmediate ,i/o

微任务 precess.nextTick  ,promise  object.observe  MutationObserver





在事件循环中 在任务队列中 只要有了运行结果 就在任务队列中存放一个事件 根据这个异步时间的类型 会被 微任务 或者 宏任务 接收 然后主线程会查看 微任务中是否事件存在 若没有  就去宏任务中去找 ;若微任务中有就将对应的回调加入到执行栈中 值到微任务队列为空 再去找 宏任务中的事件;

综上 可以知道 当前执行栈执行完毕时会先处理微任务队列中的事件 再去找宏任务中的事件 同一次事件循环中 微任务队列 总在 宏任务队列之前执行









